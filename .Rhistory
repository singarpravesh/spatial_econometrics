library("sf")
install.packages("sf")
library(sf)
st_read("foreclosures.shp")-> shape_file
shape_file
library(tiyverse)
library(tidyverse)
st_read("foreclosures.shp") %>%
as_tibble()-> shape_file
shape_file
st_read("foreclosures.shp") %>%
as_tibble()-> foreclosures
plot(foreclosures)
plot(foreclosures)
plot(foreclosures$est_fcs)
plot(foreclosures, maxplot = 5)
plot(foreclosures, max.plot = 5)
plot(foreclosures, max.plot = 5)
foreclosures
st_read("foreclosures.shp")-> foreclosures
plot(foreclosures, max.plot = 5)
library(tmap)
install.packages("tmap")
plot(foreclosures$geometry)
library(tmap)
tm_shape(foreclosure)+
tm_fill()
tm_shape(foreclosures)+
tm_fill()
tm_shape(foreclosures)+
tm_fill()+
tm_borders()
tm_shape(foreclosures)+
tm_fill()+
tm_borders()+tm_add_legend()
tm_shape(foreclosures)+
tm_fill()+
tm_borders()
?'|>'
?'<|'
install.packages(c('spdep', 'sp', 'GISTools'))
library(spdep)
library(sp)
library(sp)
library(spdep)
library(GISTools)
install.packages("GISTools")
install.packages("C:/Users/Tamang/Downloads/GISTools_0.7-4.tar.gz", repos = NULL, type = "source")
install.packages('rgeos')
install.packages("C:/Users/Tamang/Downloads/GISTools_0.7-4.tar.gz", repos = NULL, type = "source")
library(GISTools)
library(GISTools)
data("georgia")
# 2. create connectivity
?spdep::poly2nb()
# 1. Load the data from GISTools package
data("georgia")
# 2. create connectivity or build neighbours list
rook_ nb <- spdep::poly2nb(pl = georgia, queen = FALSE)
# 2. create connectivity or build neighbours list
rook_nb <- spdep::poly2nb(pl = georgia, queen = FALSE)
rook_nb
queen_nb <- spdep::poly2nb(pl = georgia, queen = TRUE)
?spdep::nb2lines()
# 3. visualise the neighbours
rook_lines <- spdep::nb2lines(nb = rook_nb, coords = sp::coordinates(georgia))
# 3. visualise the neighbours
rook_lines <- spdep::nb2lines(nb = rook_nb, coords = sp::coordinates(georgia), proj4string = georgia@proj4string)
queen_lines <- spdep::nb2lines(nb = queen_nb, coords = sp::coordinates(georgia), proj4string = georgia@proj4string)
plot(rook_lines, col = "blue")
plot(queen_lines, col = 'red', add = TRUE)
plot(rook_lines, col = "blue")
plot(queen_lines, col = 'red', add = TRUE)
# 1. Load the data from GISTools package
data("georgia")
# 2. create connectivity or build neighbours list
rook_nb <- spdep::poly2nb(pl = georgia, queen = FALSE)
queen_nb <- spdep::poly2nb(pl = georgia, queen = TRUE)
# 3. visualise the neighbours
rook_lines <- spdep::nb2lines(nb = rook_nb, coords = sp::coordinates(georgia), proj4string = georgia@proj4string)
queen_lines <- spdep::nb2lines(nb = queen_nb, coords = sp::coordinates(georgia), proj4string = georgia@proj4string)
plot(rook_lines, col = "red")
plot(queen_lines, col = 'blue', add = TRUE)
plot(rook_lines, col = "red")
plot(queen_lines, col = 'blue', add = TRUE)
plot(rook_lines, col = "red")
plot(queen_lines, col = 'blue')
library(spdep)
# Our SpatVector lux
lux
# Chunk 1
name <- LETTERS[1:10]
longitude <- c(-116.7, -120.4, -116.7, -113.5, -115.5,
-120.8, -119.5, -113.7, -113.7, -110.7)
latitude <- c(45.3, 42.6, 38.9, 42.1, 35.7, 38.9,
36.2, 39, 41.6, 36.9)
stations <- cbind(longitude, latitude)
# simulated rainfall data
set.seed(0)
precip <- round((runif(length(latitude))*10)^3)
library(tidyverse)
d <- tibble(name, longitude, latitude,
lon = c(NA, NA,-116.8, -114.2, -112.9, -111.9, -114.2, -115.4, -117.7, NA),
lat = c(NA, NA, 41.3, 42.9, 42.4, 39.8, 37.6, 38.3, 37.6, NA))
ggplot(d, aes(x = longitude,
y = latitude))+
geom_point(aes(size = (1+precip/500)))+
geom_text(aes(label = name), vjust = 1, hjust = 2, col = "blue") -> plot
# Chunk 2
# Add a polygon with lon and lat variables
plot +
geom_polygon(aes(x = lon, y = lat), alpha = 0.5)+
geom_path(col = "red")
# Chunk 3
library(terra)
# Consider the dataset d
d1 <- vect(d)
geom(d1)
class(d1)
# Chunk 4
d1 <- vect(d, crs = "+proj=longlat +datum=WGS84")
crs(d1)
# Chunk 5
# First create a dataframe with the same number of rows as the geometries
df <- tibble(ID = 1:length(d1),
precip = precip) # we had generated precip before.
d2 <- vect(as.matrix(d[, 2:3]),  atts = df, crs = "+proj=longlat +datum=WGS84") # the dataframe 'd' had to be changed
# to a matrix before using the 'atts' argument
# Chunk 6
vect(as.matrix(d[, 2:3]), crs = "+proj=longlat +datum=WGS84", type = "lines") |> plot()
vect(as.matrix(d[, 2:3]), crs = "+proj=longlat +datum=WGS84", type = "polygons") |> plot(col = "blue")
# Chunk 7
r <- rast(ncol = 10, nrow = 10, xmin = -150, xmax = -80, ymin = 20, ymax = 60)
# Chunk 8
values(r) <- 1:ncell(r)
r
# Chunk 9
lon <- c(-116.8, -114.2, -112.9, -111.9, -114.2, -115.4, -117.7)
lat <- c(41.3, 42.9, 42.4, 39.8, 37.6, 38.3, 37.6)
lonlat <- cbind(id=1, part=1, lon, lat)
pts <- vect(lonlat, type="points", crs="+proj=longlat +datum=WGS84")
pols <- vect(lonlat, type="polygons", crs="+proj=longlat +datum=WGS84")
plot(r)
points(pts)
lines(pols)
# Chunk 10
r2  <- r^2
r3 <- sqrt(r)
s <- c(r, r2, r3)
plot(s)
# Chunk 11
library(terra)
system.file("ex/lux.shp", package = "terra") -> lux
vect(lux) # the vect() returns the `SpatVector` objects
# Chunk 12
vect(lux) |> crs()
# Chunk 13
vect(lux) -> lux1
crs(lux1) <- " "
crs(lux1) <- "+proj=longlat +datum=WGS84"
# Chunk 14
# Define the crs
crs <- "+proj=robin +datum=WGS84" # here we use the Robinson projection
# Our SpatVector lux
lux
# Our SpatVector lux1
lux1
# Our SpatVector lux1 has the CRS '+proj=longlat +datum=WGS84'
crs(lux1)
rob <- terra::project(lux1, crs)
rob
class(lux1)
lux2 <- project(rob, '+proj=longlat +datum=WGS84')
lux2
lux1
names(lux1)
plot(lux1, "NAME_2")
as.data.frame(lux1) |> head()
# Geometry
geom(lux1) |> head()
library(tidyverse)
# Variables
as.data.frame(lux1) %>%
head()
as.data.frame(lux1) %>%
select(POP)
select(lux1, population)
select(lux1, POP)
lux1$POP
class(lux1)
as.data.frame(lux1)[, "POP"]
# Extracting variables without converting
lux1$POP
# Extracting variables without converting
lux1$POP|> class()
as.data.frame(lux1)[, "POP"] |> class()
lux$lets <- sample(letters, nrow(lux1))
sample(letters, nrow(lux1))
lux1$lets <- sample(letters, nrow(lux1))
lux1
library(readxl)
level <- read_excel("C:/Users/Pravesh/Downloads/Level.xlsx")
level
summary(level)
View(level)
class(level$`Water Sufficiency score`)
library(tidyverse)
level <- level |>
mutate(`Frequency of water supply score` = as.numeric(`Frequency of water supply score`))
level <- read_excel("C:/Users/Pravesh/Downloads/Level.xlsx")
level <- read_excel("C:/Users/Pravesh/Downloads/Level.xlsx")
View(level)
pca <- read_excel("C:/Users/Pravesh/Downloads/pca.xlsx")
View(pca)
summary(pca)
resource_pca <- prcomp(pca[, 2:5], scale = TRUE)
resource_pca
summary(resource_pca)
resource_pca$rotation # weights or loadings
(weights_unnormalized <- resource_pca$rotation)
(weights_normalized <- scale(weights_unnormalized, scale = FALSE) / sqrt(rowSums(weights_unnormalized^2)))
resource_pca <- prcomp(pca[, 2:5], scale = FALSE)
summary(resource_pca)
resource_pca$rotation # weights or loadings
(weights_unnormalized <- resource_pca$rotation)
(weights_normalized <- scale(weights_unnormalized, scale = FALSE) / sqrt(rowSums(weights_unnormalized^2)))
scale(weights_unnormalized, scale = FALSE)
scale(weights_unnormalized, scale = TRUE)
weights_unnormalized
(weights_normalized <- scale(weights_unnormalized, scale = TRUE) / sqrt(rowSums(weights_unnormalized^2)))
data(decathlon2)
library(factoextra)
data(decathlon2)
decathlon2.active <- decathlon2[1:23, 1:10]
decathlon2.active
res.pca <- prcomp(decathlon2.active, scale = TRUE)
res.pca
(weights_normalized1 <- scale(res.pca$rotation, scale = TRUE) / sqrt(rowSums(res.pca$rotation^2)))
(weights_normalized1 <- scale(res.pca$rotation, scale = FALSE) / sqrt(rowSums(res.pca$rotation^2)))
colSums(weights_normalized1)
rowsum(weights_normalized1)
rowSums(weights_normalized1)
res.pca
weights_unnormalized1 <-res.pca$rotation
weights_unnormalized1
class(weights_unnormalized1)
weights_unnormalized1 <-as.dataframe(res.pca$rotation)
weights_unnormalized1 <-as.data.frame(res.pca$rotation)
class(weights_unnormalized1)
library(tidyverse)
weights_unnormalized1 |>
mutate(PC1_n = PC1/sum(PC1))
1/sum(weights_unnormalized1$PC1)
k <- 1/sum(weights_unnormalized1$PC1)
weights_unnormalized1 |>
mutate(PC1_n = k*PC1)
weights_unnormalized1 |>
mutate(PC1_n = k*PC1) |>
rowSums(PC1_n)
weights_unnormalized1 |>
mutate(PC1_n = k*PC1) |>
summarise(sum(PC1_n))
k <- 1/sum(abs(weights_unnormalized1$PC1))
k
weights_unnormalized1 |>
mutate(PC1_n = k*PC1) |>
summarise(sum(PC1_n))
weights_unnormalized1 |>
mutate(PC1_n = k*abs(PC1)) |>
summarise(sum(PC1_n))
abs(weights_unnormalized1$PC1)
weights_unnormalized1 |>
mutate(PC1_n = k*abs(PC1))
resource_pca <- prcomp(pca[, 2:5], scale = FALSE)
resource_pca$rotation # weights or loadings
(weights_unnormalized <- resource_pca$rotation)
k <- 1/sum(abs(weights_unnormalized$PC1))
weights_unnormalized <- as.data.frame(resource_pca$rotation)
k <- 1/sum(abs(weights_unnormalized$PC1))
weights_unnormalized |>
mutate(PC1 = k*abs(PC1)) |>
summarise(sum(PC1))
weights_unnormalized |>
mutate(PC1 = k*abs(PC1))
weights_unnormalized |>
mutate(PC1 = round(k*abs(PC1)), 2)
weights_unnormalized |>
mutate(PC1 = round(k*abs(PC1)), 3)
weights_unnormalized |>
mutate(PC1_n = round(k*abs(PC1)), digits = 4)
weights_unnormalized |>
mutate(PC1_n = round(k*abs(PC1), 3))
weights_unnormalized |>
mutate(PC1_n = round(k*abs(PC1), 2))
weights_unnormalized |>
mutate(PC1_n = round(k*abs(PC1), 1))
weights_unnormalized |>
mutate(PC1_n = round(k*abs(PC1), 1),
PC2_n = round(k*abs(PC2), 1),
PC3_n = round(k*abs(PC3), 1),
PC4_n = round(k*abs(PC4), 1))
get_eigenvalue(resource_pca)
summary(resource_pca)
resource_pca$rotation
weights_unnormalized |>
mutate(PC1_n = round(k*abs(PC1), 1),
PC2_n = round(k*abs(PC2), 1),
PC3_n = round(k*abs(PC3), 1),
PC4_n = round(k*abs(PC4), 1)) # note the -ve signs
# Create a sample dataset
data <- data.frame(
Country = c("Country1", "Country2", "Country3"),
Physical = c(0.7, 0.5, 0.8),  # Replace with actual values
Economic = c(0.6, 0.4, 0.7),  # Replace with actual values
Development = c(0.8, 0.6, 0.9),  # Replace with actual values
Environmental = c(0.5, 0.3, 0.6)  # Replace with actual values
)
data
# Define weights
weights <- c(0.25, 0.25, 0.25, 0.25)
data$CV_Physical <- data$Physical * weights[1]
data$CV_Economic <- data$Economic * weights[2]
data$CV_Development <- data$Development * weights[3]
data$CV_Environmental <- data$Environmental * weights[4]
# Calculate Water Poverty Index
data$WPI <- (data$CV_Physical + data$CV_Economic) / 2 - (data$CV_Development + data$CV_Environmental) / 2
data
resource_pca$rotation # weights or loadings
k1 <- 1/sum(abs(weights_unnormalized$PC1))
k2 <- 1/sum(abs(weights_unnormalized$PC2))
k3 <- 1/sum(abs(weights_unnormalized$PC3))
k4 <- 1/sum(abs(weights_unnormalized$PC4))
weights_unnormalized |>
mutate(PC1_n = round(k1*abs(PC1), 1),
PC2_n = round(k2*abs(PC2), 1),
PC3_n = round(k3*abs(PC3), 1),
PC4_n = round(k4*abs(PC4), 1)) # note the -ve signs
summary(pca)
names(pca)
summary(pca)
